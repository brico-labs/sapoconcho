{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sapoconcho sapoconcho 1. f. ( galego ) O sapoconcho ( Emys orbicularis ) \u00e9 unha tartaruga da familia Emydidae e \u00fanica representante do x\u00e9nero Emys, que se atopa no centro e sur de Europa, Asia occidental, Norteam\u00e9rica e a zona mediterr\u00e1nea de \u00c1frica. Sapoconcho es un robot open-source educativo con el que puedes introducirte en el mundo de la rob\u00f3tica y la programaci\u00f3n. Es apropiado para ni\u00f1os de a partir de 11 a\u00f1os. Est\u00e1 ideado con el objetivo de ser lo m\u00e1s accesible posible: Abierto y documentado. Componentes comunes, f\u00e1ciles de encontrar y econ\u00f3micos. Dise\u00f1o sencillo para imprimir y montar. Modular y extensible. En este sitio encontrar\u00e1s: Historia del proyecto Listado de materiales para crear un kit de Sapoconcho. Tutorial de montaje y programaci\u00f3n de un Sapoconcho. Guia y materiales para preparar un taller de Sapoconcho.","title":"Inicio"},{"location":"#sapoconcho","text":"sapoconcho 1. f. ( galego ) O sapoconcho ( Emys orbicularis ) \u00e9 unha tartaruga da familia Emydidae e \u00fanica representante do x\u00e9nero Emys, que se atopa no centro e sur de Europa, Asia occidental, Norteam\u00e9rica e a zona mediterr\u00e1nea de \u00c1frica. Sapoconcho es un robot open-source educativo con el que puedes introducirte en el mundo de la rob\u00f3tica y la programaci\u00f3n. Es apropiado para ni\u00f1os de a partir de 11 a\u00f1os. Est\u00e1 ideado con el objetivo de ser lo m\u00e1s accesible posible: Abierto y documentado. Componentes comunes, f\u00e1ciles de encontrar y econ\u00f3micos. Dise\u00f1o sencillo para imprimir y montar. Modular y extensible. En este sitio encontrar\u00e1s: Historia del proyecto Listado de materiales para crear un kit de Sapoconcho. Tutorial de montaje y programaci\u00f3n de un Sapoconcho. Guia y materiales para preparar un taller de Sapoconcho.","title":"Sapoconcho"},{"location":"equipo/","text":"Equipo Sapoconcho es un proyecto de la asociaci\u00f3n Bricolabs . Su creador y actual mantenedor del proyecto es: F\u00e9lix En el proyecto han colaborado: Sergio Manolo Rafa Dani","title":"Equipo"},{"location":"equipo/#equipo","text":"Sapoconcho es un proyecto de la asociaci\u00f3n Bricolabs . Su creador y actual mantenedor del proyecto es: F\u00e9lix En el proyecto han colaborado: Sergio Manolo Rafa Dani","title":"Equipo"},{"location":"historia/","text":"Historia Yet Another Training Robot. El origen Sabemos que lo que hacemos no es ninguna novedad. Este tipo de robots se puede encontrar en modelos comerciales y en muchos tutoriales a lo largo y ancho de la web. Sin embargo tenemos una experiencia de varios a\u00f1os en Bricolabs que no queremos que se pierda. Llevamos tiempo cocinando la idea de crear un proyecto paralelo en forma a Escornabot para el siguiente segmento de edad, aunque por supuesto esto no es excluyente. A lo largo del a\u00f1o 2013 participamos en la iniciativa KiiCS de los Museos Cient\u00edficos de A Coru\u00f1a que se desarroll\u00f3 en nuestra casa de acogida, la Domus. En estos talleres se utilizaron unos kits comerciales y que tienen algunas limitaciones adem\u00e1s de su precio. Los destinatarios en aquella ocasi\u00f3n eran adolescentes y despu\u00e9s se extendi\u00f3 a profesores de tecnolog\u00eda, que se han mantenido en otros posteriores. Adem\u00e1s de dise\u00f1ar y probar los cursos se crearon librer\u00edas de Arduino para el control de los motores con instrucciones sencillas. Una buena experiencia que nos sirvi\u00f3 para ver qu\u00e9 cosas funcionan bien en un curso y resultan entretenidas y divertidas. Casi al mismo tiempo fue surgiendo el proyecto Escornabot y el buen funcionamiento de \u00e9ste nos anima a buscar un proyecto complementario dirigido a un segmento de edad mayor y a intentar otros objetivos: programar los robots con c\u00f3digo fuente. Empezar editando los programas que ya existen, y poco a poco animarse a crear otras funciones y -por qu\u00e9 no- a\u00f1adir otros m\u00f3dulos electr\u00f3nicos. Adem\u00e1s en los \u00faltimos a\u00f1os varios miembros de Bricolabs hemos hecho nuestros propios robots 'tortuga' con muchas funciones diferentes. Tambi\u00e9n hemos seguido experimentando con diferentes plataformas de hardware y diferentes lenguajes de programaci\u00f3n. La idea es poner orden en toda la documentaci\u00f3n que ya existe y que fue apareciendo por nuestra wiki . De ese modo se pretende poner en un \u00fanico sitio toda la informaci\u00f3n necesaria para hacer dos cosas: Construir tu propio robot paso a paso, programarlo y usarlo como base para aprender o construir lo que quieras. Un curso completo autocontenido para que cualquiera puede ofrecerlo, modificarlo y extender la cadena del conocimiento hasta el infinito y m\u00e1s all\u00e1. Los primeros prototipos Prototipo Wall.E Teseo KIS KIS con sensores Sapoconcho original de 90mm Este fue el primer dise\u00f1o con piezas impresas ( aunque hubo una fase anterior recortando protoboards). Fue un dise\u00f1o que se ajust\u00f3 a 90mm de di\u00e1metro pensando en que pudiese entrar en el concurso de laberinto de la OSHWDEM . S\u00f3lo se necesitaban separadores de circuitos de 25mm (4 ud) y tornillos M2.5\u00d720 para montar los motores al chasis inferior con sus soportes. Los pasos para montarlo eran los siguientes: Monta la bola y los motores en la base inferior. La primera entra a presi\u00f3n, los motores con sus soportes atornillados (M2.5\u00d720 tuerca) . Pega la controladora de motores y el portapilas a la base inferior con cinta adhesiva de doble cara. Monta la base superior con los separadores de circuitos. Pega la breadboard en la base superior para el Arduino micro. En su lugar puedes usar un Arduino UNO, que tambi\u00e9n cabe. (opcional). Monta los soportes para los sensores SR-04 sobre la base superior. Conecta la placa de motores al Arduino con el esquema siguiente. Sapoconcho 2021. The Expanse Los modelos iniciales del proyecto utilizaban micromotores de tipo N20 en un chasis de 90mm de di\u00e1metro. Aunque sigue siendo un dise\u00f1o v\u00e1lido, en 2021 hemos creado un nuevo chasis un poco m\u00e1s grande para poder expandir el ecosistema. El nuevo chasis utiliza motores amarillos y tiene 120mm de di\u00e1metro, manteniendo el formato tortuga. Sabemos que 'motor amarillo' es un t\u00e9rmino muy gen\u00e9rico, pero si est\u00e1s metido un poco en el mundo maker/DIY o haces una b\u00fasqueda r\u00e1pida en tu plataforma favorita ver\u00e1s a qu\u00e9 nos referimos. Es un tipo de motor de corriente continua muy usado en todo tipo de proyectos y kits, muy f\u00e1cil de conseguir y muy econ\u00f3mico. Esos motores suelen traer una rueda pero no es necesario que la compres, utilizaremos una impresa de menor tama\u00f1o con una goma para que agarre. Adem\u00e1s de los nuevos motores, el nuevo tama\u00f1o permite utilizar un pack de 4 pilas AA (y a\u00f1adirle un m\u00f3dulo step-up si es necesario) o una bater\u00eda recargable 18650. Cuando tengan motores Epstein en Aliexpress habr\u00e1 que reestudiar el proyecto. Esto nos va a permitir aumentar la versatilidad del proyecto al poder meter m\u00e1s elementos en el chasis, y ampliar el n\u00famero de plataformas hardware disponibles. Sapoconcho mClon Cuando pensamos en ampliar el ecosistema inmediatamente se nos ocurri\u00f3 que ser\u00eda un desperdicio no aprovechar el trabajo estupendo del proyecto mClon de A Industriosa . Como el mClon utiliza dos motores amarillos, sensores de l\u00edneas y de ultrasonidos, la compatibilidad es total. En realidad lo \u00fanico que hemos hecho es un chasis en el que se pueden montar los mismos elementos, tanto en la versi\u00f3n ShieldClon como en la versi\u00f3n ProtoShield. Os mostramos s\u00f3lo las fotos del resultado. El proyecto est\u00e1 fant\u00e1sticamente documentado en su web. Necesitar\u00e1s usar una versi\u00f3n especial de la placa superior que tiene ya los soportes para un Arduino UNO (upper_plate_UNO_v1 \u00f3 v2). Tambi\u00e9n una versi\u00f3n especial de la placa inferior que tiene unos soporte con parasol para los sensores de infrarrojos. Esa pieza es mejor que sea negra o cubrir esos parasoles con cinta o pintura negra. Versi\u00f3n ProtoShield Versi\u00f3n ShieldClon Para poder utilizar el portapilas 4xAA (con step-up) es necesario hacer unos peque\u00f1os hacks a la placa de XDeSIG. Adem\u00e1s de no montar el conector USB, hay que cambiar la resistencia de 2.2 ohm por una de 0 ohm (s\u00ed, has le\u00eddo bien, cero, aunque puedes tambi\u00e9n hacer un puente con un cable), y en lugar del step-up para cargar la bater\u00eda colocar un regulador LM7805. Versiones procrastinadas Sapoconcho Pico: el nuevo microcontrolador de Raspberry y una controladora de motores nos permitir\u00e1 iniciarnos en el mundo de MicroPython. Sapoconcho micro:bit: la renovada plataforma de BBC nos permitir\u00e1 elegir entre programar con bloques tipo Scratch o Python. Sapoconcho Zero: para quien quiera Python a toda potencia con una Raspi Zero y diferentes HATs. Sapoconcho RC: instala la placa que recomendamos en el proyecto MeccanoRC y tu chasis ya se mueve!","title":"Historia"},{"location":"historia/#historia","text":"Yet Another Training Robot.","title":"Historia"},{"location":"historia/#el-origen","text":"Sabemos que lo que hacemos no es ninguna novedad. Este tipo de robots se puede encontrar en modelos comerciales y en muchos tutoriales a lo largo y ancho de la web. Sin embargo tenemos una experiencia de varios a\u00f1os en Bricolabs que no queremos que se pierda. Llevamos tiempo cocinando la idea de crear un proyecto paralelo en forma a Escornabot para el siguiente segmento de edad, aunque por supuesto esto no es excluyente. A lo largo del a\u00f1o 2013 participamos en la iniciativa KiiCS de los Museos Cient\u00edficos de A Coru\u00f1a que se desarroll\u00f3 en nuestra casa de acogida, la Domus. En estos talleres se utilizaron unos kits comerciales y que tienen algunas limitaciones adem\u00e1s de su precio. Los destinatarios en aquella ocasi\u00f3n eran adolescentes y despu\u00e9s se extendi\u00f3 a profesores de tecnolog\u00eda, que se han mantenido en otros posteriores. Adem\u00e1s de dise\u00f1ar y probar los cursos se crearon librer\u00edas de Arduino para el control de los motores con instrucciones sencillas. Una buena experiencia que nos sirvi\u00f3 para ver qu\u00e9 cosas funcionan bien en un curso y resultan entretenidas y divertidas. Casi al mismo tiempo fue surgiendo el proyecto Escornabot y el buen funcionamiento de \u00e9ste nos anima a buscar un proyecto complementario dirigido a un segmento de edad mayor y a intentar otros objetivos: programar los robots con c\u00f3digo fuente. Empezar editando los programas que ya existen, y poco a poco animarse a crear otras funciones y -por qu\u00e9 no- a\u00f1adir otros m\u00f3dulos electr\u00f3nicos. Adem\u00e1s en los \u00faltimos a\u00f1os varios miembros de Bricolabs hemos hecho nuestros propios robots 'tortuga' con muchas funciones diferentes. Tambi\u00e9n hemos seguido experimentando con diferentes plataformas de hardware y diferentes lenguajes de programaci\u00f3n. La idea es poner orden en toda la documentaci\u00f3n que ya existe y que fue apareciendo por nuestra wiki . De ese modo se pretende poner en un \u00fanico sitio toda la informaci\u00f3n necesaria para hacer dos cosas: Construir tu propio robot paso a paso, programarlo y usarlo como base para aprender o construir lo que quieras. Un curso completo autocontenido para que cualquiera puede ofrecerlo, modificarlo y extender la cadena del conocimiento hasta el infinito y m\u00e1s all\u00e1.","title":"El origen"},{"location":"historia/#los-primeros-prototipos","text":"Prototipo Wall.E Teseo KIS KIS con sensores","title":"Los primeros prototipos"},{"location":"historia/#sapoconcho-original-de-90mm","text":"Este fue el primer dise\u00f1o con piezas impresas ( aunque hubo una fase anterior recortando protoboards). Fue un dise\u00f1o que se ajust\u00f3 a 90mm de di\u00e1metro pensando en que pudiese entrar en el concurso de laberinto de la OSHWDEM . S\u00f3lo se necesitaban separadores de circuitos de 25mm (4 ud) y tornillos M2.5\u00d720 para montar los motores al chasis inferior con sus soportes. Los pasos para montarlo eran los siguientes: Monta la bola y los motores en la base inferior. La primera entra a presi\u00f3n, los motores con sus soportes atornillados (M2.5\u00d720 tuerca) . Pega la controladora de motores y el portapilas a la base inferior con cinta adhesiva de doble cara. Monta la base superior con los separadores de circuitos. Pega la breadboard en la base superior para el Arduino micro. En su lugar puedes usar un Arduino UNO, que tambi\u00e9n cabe. (opcional). Monta los soportes para los sensores SR-04 sobre la base superior. Conecta la placa de motores al Arduino con el esquema siguiente.","title":"Sapoconcho original de 90mm"},{"location":"historia/#sapoconcho-2021-the-expanse","text":"Los modelos iniciales del proyecto utilizaban micromotores de tipo N20 en un chasis de 90mm de di\u00e1metro. Aunque sigue siendo un dise\u00f1o v\u00e1lido, en 2021 hemos creado un nuevo chasis un poco m\u00e1s grande para poder expandir el ecosistema. El nuevo chasis utiliza motores amarillos y tiene 120mm de di\u00e1metro, manteniendo el formato tortuga. Sabemos que 'motor amarillo' es un t\u00e9rmino muy gen\u00e9rico, pero si est\u00e1s metido un poco en el mundo maker/DIY o haces una b\u00fasqueda r\u00e1pida en tu plataforma favorita ver\u00e1s a qu\u00e9 nos referimos. Es un tipo de motor de corriente continua muy usado en todo tipo de proyectos y kits, muy f\u00e1cil de conseguir y muy econ\u00f3mico. Esos motores suelen traer una rueda pero no es necesario que la compres, utilizaremos una impresa de menor tama\u00f1o con una goma para que agarre. Adem\u00e1s de los nuevos motores, el nuevo tama\u00f1o permite utilizar un pack de 4 pilas AA (y a\u00f1adirle un m\u00f3dulo step-up si es necesario) o una bater\u00eda recargable 18650. Cuando tengan motores Epstein en Aliexpress habr\u00e1 que reestudiar el proyecto. Esto nos va a permitir aumentar la versatilidad del proyecto al poder meter m\u00e1s elementos en el chasis, y ampliar el n\u00famero de plataformas hardware disponibles.","title":"Sapoconcho 2021. The Expanse"},{"location":"historia/#sapoconcho-mclon","text":"Cuando pensamos en ampliar el ecosistema inmediatamente se nos ocurri\u00f3 que ser\u00eda un desperdicio no aprovechar el trabajo estupendo del proyecto mClon de A Industriosa . Como el mClon utiliza dos motores amarillos, sensores de l\u00edneas y de ultrasonidos, la compatibilidad es total. En realidad lo \u00fanico que hemos hecho es un chasis en el que se pueden montar los mismos elementos, tanto en la versi\u00f3n ShieldClon como en la versi\u00f3n ProtoShield. Os mostramos s\u00f3lo las fotos del resultado. El proyecto est\u00e1 fant\u00e1sticamente documentado en su web. Necesitar\u00e1s usar una versi\u00f3n especial de la placa superior que tiene ya los soportes para un Arduino UNO (upper_plate_UNO_v1 \u00f3 v2). Tambi\u00e9n una versi\u00f3n especial de la placa inferior que tiene unos soporte con parasol para los sensores de infrarrojos. Esa pieza es mejor que sea negra o cubrir esos parasoles con cinta o pintura negra. Versi\u00f3n ProtoShield Versi\u00f3n ShieldClon Para poder utilizar el portapilas 4xAA (con step-up) es necesario hacer unos peque\u00f1os hacks a la placa de XDeSIG. Adem\u00e1s de no montar el conector USB, hay que cambiar la resistencia de 2.2 ohm por una de 0 ohm (s\u00ed, has le\u00eddo bien, cero, aunque puedes tambi\u00e9n hacer un puente con un cable), y en lugar del step-up para cargar la bater\u00eda colocar un regulador LM7805.","title":"Sapoconcho mClon"},{"location":"historia/#versiones-procrastinadas","text":"Sapoconcho Pico: el nuevo microcontrolador de Raspberry y una controladora de motores nos permitir\u00e1 iniciarnos en el mundo de MicroPython. Sapoconcho micro:bit: la renovada plataforma de BBC nos permitir\u00e1 elegir entre programar con bloques tipo Scratch o Python. Sapoconcho Zero: para quien quiera Python a toda potencia con una Raspi Zero y diferentes HATs. Sapoconcho RC: instala la placa que recomendamos en el proyecto MeccanoRC y tu chasis ya se mueve!","title":"Versiones procrastinadas"},{"location":"kit/","text":"Un Kit Sapoconcho Un kit de Sapoconcho es un paquete con todas las piezas necesarias para montar un Sapoconcho. Para hacerte uno necesitar\u00e1s una serie de materiales que detallaremos a continuaci\u00f3n: Piezas imprimibles El chasis de Sapoconcho consta de las siguientes piezas: Bases superior e inferior. Soporte de motores (1 unidad). Pilares de uni\u00f3n (o separaci\u00f3n) de las dos bases (4 unidades). Pueden usarse en su lugar separadores de circuitos de 30mm. Ruedas (2 unidades). Soporte de sensores de ultrasonidos (1 \u00f3 2 unidades). En una impresora t\u00edpica de 200x200mm se pueden imprimir todas las piezas en dos tandas. Todas las piezas est\u00e1n en este repositorio de Github . Ah\u00ed puedes encontrar los archivos originales de OpenSCAD para modificarlos a tu gusto o los STL para imprimir directamente. Listado de materiales (BOM) Arduino UNO o compatible. Protoshield para Arduino UNO. Driver de motores TB6612 o DRV8833. Dos motores amarillos. Sabemos que es un t\u00e9rmino muy gen\u00e9rico, pero si est\u00e1s metido un poco en el mundo maker/DIY o haces una b\u00fasqueda r\u00e1pida en tu plataforma favorita ver\u00e1s a qu\u00e9 nos referimos. Es un tipo de motor de corriente continua muy usado en todo tipo de proyectos y kits, muy f\u00e1cil de conseguir y muy econ\u00f3mico. No necesitamos las ruedas que traen a veces. Gomas de fontaner\u00eda para las ruedas (2ud). Medida 45\u00d73 mm. Bola de acero de 10 mm. Sensores ultras\u00f3nicos HC-SR04 (1 \u00f3 2 ud). Sensores de l\u00edneas por infrarrojos (2 ud). Portapilas para montar 4 pilas AA (dos encima y dos debajo). Elevador de tensi\u00f3n DC-DC (step-up, con los integrados LM2587/XL6009). Clavija de alimentaci\u00f3n para Arduino UNO (5.5\u00d72.1 mm). Tornillos M3 (12 ud M3x10, 4 ud M3x30, 4d M3x6). Tuercas M3 (4 ud). Cables Dupont M-H de 20mm y de 10mm. Cable USB-A a USB-B Cables de tres colores (rojo, negro y otro) para breadboard. Por si os es de utilidad, os dejamos una lista de la compra en Amazon .","title":"Kit"},{"location":"kit/#un-kit-sapoconcho","text":"Un kit de Sapoconcho es un paquete con todas las piezas necesarias para montar un Sapoconcho. Para hacerte uno necesitar\u00e1s una serie de materiales que detallaremos a continuaci\u00f3n:","title":"Un Kit Sapoconcho"},{"location":"kit/#piezas-imprimibles","text":"El chasis de Sapoconcho consta de las siguientes piezas: Bases superior e inferior. Soporte de motores (1 unidad). Pilares de uni\u00f3n (o separaci\u00f3n) de las dos bases (4 unidades). Pueden usarse en su lugar separadores de circuitos de 30mm. Ruedas (2 unidades). Soporte de sensores de ultrasonidos (1 \u00f3 2 unidades). En una impresora t\u00edpica de 200x200mm se pueden imprimir todas las piezas en dos tandas. Todas las piezas est\u00e1n en este repositorio de Github . Ah\u00ed puedes encontrar los archivos originales de OpenSCAD para modificarlos a tu gusto o los STL para imprimir directamente.","title":"Piezas imprimibles"},{"location":"kit/#listado-de-materiales-bom","text":"Arduino UNO o compatible. Protoshield para Arduino UNO. Driver de motores TB6612 o DRV8833. Dos motores amarillos. Sabemos que es un t\u00e9rmino muy gen\u00e9rico, pero si est\u00e1s metido un poco en el mundo maker/DIY o haces una b\u00fasqueda r\u00e1pida en tu plataforma favorita ver\u00e1s a qu\u00e9 nos referimos. Es un tipo de motor de corriente continua muy usado en todo tipo de proyectos y kits, muy f\u00e1cil de conseguir y muy econ\u00f3mico. No necesitamos las ruedas que traen a veces. Gomas de fontaner\u00eda para las ruedas (2ud). Medida 45\u00d73 mm. Bola de acero de 10 mm. Sensores ultras\u00f3nicos HC-SR04 (1 \u00f3 2 ud). Sensores de l\u00edneas por infrarrojos (2 ud). Portapilas para montar 4 pilas AA (dos encima y dos debajo). Elevador de tensi\u00f3n DC-DC (step-up, con los integrados LM2587/XL6009). Clavija de alimentaci\u00f3n para Arduino UNO (5.5\u00d72.1 mm). Tornillos M3 (12 ud M3x10, 4 ud M3x30, 4d M3x6). Tuercas M3 (4 ud). Cables Dupont M-H de 20mm y de 10mm. Cable USB-A a USB-B Cables de tres colores (rojo, negro y otro) para breadboard. Por si os es de utilidad, os dejamos una lista de la compra en Amazon .","title":"Listado de materiales (BOM)"},{"location":"montaje/","text":"Montaje Sapoconcho Ahora que ya tienes tu kit, \u00a1vamos a montar el Sapoconcho! Montaje mec\u00e1nico El chasis base tiene pocas piezas y el montaje es muy sencillo. Paso 1 : Los motores amarillos se unir\u00e1n al soporte con 4 tornillos M3x30. Paso 2 : Unir la base inferior al soporte con dos tornillos M3x12. Tambi\u00e9n se puede poner ahora la bola loca o 'ballcaster', el tercer punto de apoyo. Paso 3 : Montar los 4 pilares a la base inferior con 4 tornillos M3x10. Paso 4 : Montar la base superior a los pilares con otros 4 tornillos M3x10. Ojo a la orientaci\u00f3n en la foto. Paso 5 : Colocar las ruedas -cada una con su 'neum\u00e1tico'-, montar el Arduino UNO con tornillos M3 (dos en diagonal son suficientes) y pinchar la Shield sobre \u00e9l. Montaje el\u00e9ctrico Arduino no puede operar directamente un motor. Necesita un intermediario o driver. En este caso utilizaremos el DRV8833. Nota Con una peque\u00f1a variaci\u00f3n en el cableado, el driver Toshiba TB6612 tambi\u00e9n es compatible. Para conectar el driver vamos a usar cable r\u00edgido de colores cortado a medida. Las conexiones son las de la imagen. Aunque el color de los cables no influye en el funcionamiento, para la alimentaci\u00f3n y masa (tierra) se suelen utilizar los colores rojo y negro respectivamente. A continuaci\u00f3n hay que pinchar el driver teniendo cuidado con que los pines y los cable coincidan como en la foto. Cableado de los motores Necesitamos cuatro cables Dupont de 20cmm soldados en un extremos a los motores y con punta macho en el otro extremo para la protoshield. Pueden ir agrupados para hacer un montaje m\u00e1s elegante, aunque no es imprescindible. Tampoco es imprescindible, pero si una buena idea a\u00f1adir un condensador cer\u00e1mico de 0.1uF (c\u00f3digo 104) en paralelo en cada motor. Los cables Dupont que vengan de los motores se conectar\u00e1n ahora en los pines correspondientes. Si al probar las funciones de movimiento alguna rueda gira al rev\u00e9s, puedes intercambiar los cables de ese motor. Alimentaci\u00f3n Para alimentaci\u00f3n utilizaremos un portapilas para 4 pilas AA. Y para que valga para cualquier proyecto, puedas usar pilas recargables y reduzcamos la contaminaci\u00f3n a\u00f1adiremos siempre un regulador dc-dc elevador para elevar la tensi\u00f3n de salida (step-up). El LM2587 y el XL6009 valen y tienen un tornillo para regular la tensi\u00f3n de salida; un buen valor es 7,5v. Las conexiones del step-up son muy sencillas: entrada positiva/negativa (IN+ rojo/IN- negro) desde el portapilas y salida positiva/negaviva (OUT+ rojo/OUT- negro) a la clavija. Adem\u00e1s sacaremos un cable con un extremo Dupont macho (bstante largo) para alimentar el driver antes del step-up, de IN+ a VM.","title":"Montaje"},{"location":"montaje/#montaje-sapoconcho","text":"Ahora que ya tienes tu kit, \u00a1vamos a montar el Sapoconcho!","title":"Montaje Sapoconcho"},{"location":"montaje/#montaje-mecanico","text":"El chasis base tiene pocas piezas y el montaje es muy sencillo. Paso 1 : Los motores amarillos se unir\u00e1n al soporte con 4 tornillos M3x30. Paso 2 : Unir la base inferior al soporte con dos tornillos M3x12. Tambi\u00e9n se puede poner ahora la bola loca o 'ballcaster', el tercer punto de apoyo. Paso 3 : Montar los 4 pilares a la base inferior con 4 tornillos M3x10. Paso 4 : Montar la base superior a los pilares con otros 4 tornillos M3x10. Ojo a la orientaci\u00f3n en la foto. Paso 5 : Colocar las ruedas -cada una con su 'neum\u00e1tico'-, montar el Arduino UNO con tornillos M3 (dos en diagonal son suficientes) y pinchar la Shield sobre \u00e9l.","title":"Montaje mec\u00e1nico"},{"location":"montaje/#montaje-electrico","text":"Arduino no puede operar directamente un motor. Necesita un intermediario o driver. En este caso utilizaremos el DRV8833. Nota Con una peque\u00f1a variaci\u00f3n en el cableado, el driver Toshiba TB6612 tambi\u00e9n es compatible. Para conectar el driver vamos a usar cable r\u00edgido de colores cortado a medida. Las conexiones son las de la imagen. Aunque el color de los cables no influye en el funcionamiento, para la alimentaci\u00f3n y masa (tierra) se suelen utilizar los colores rojo y negro respectivamente. A continuaci\u00f3n hay que pinchar el driver teniendo cuidado con que los pines y los cable coincidan como en la foto. Cableado de los motores Necesitamos cuatro cables Dupont de 20cmm soldados en un extremos a los motores y con punta macho en el otro extremo para la protoshield. Pueden ir agrupados para hacer un montaje m\u00e1s elegante, aunque no es imprescindible. Tampoco es imprescindible, pero si una buena idea a\u00f1adir un condensador cer\u00e1mico de 0.1uF (c\u00f3digo 104) en paralelo en cada motor. Los cables Dupont que vengan de los motores se conectar\u00e1n ahora en los pines correspondientes. Si al probar las funciones de movimiento alguna rueda gira al rev\u00e9s, puedes intercambiar los cables de ese motor. Alimentaci\u00f3n Para alimentaci\u00f3n utilizaremos un portapilas para 4 pilas AA. Y para que valga para cualquier proyecto, puedas usar pilas recargables y reduzcamos la contaminaci\u00f3n a\u00f1adiremos siempre un regulador dc-dc elevador para elevar la tensi\u00f3n de salida (step-up). El LM2587 y el XL6009 valen y tienen un tornillo para regular la tensi\u00f3n de salida; un buen valor es 7,5v. Las conexiones del step-up son muy sencillas: entrada positiva/negativa (IN+ rojo/IN- negro) desde el portapilas y salida positiva/negaviva (OUT+ rojo/OUT- negro) a la clavija. Adem\u00e1s sacaremos un cable con un extremo Dupont macho (bstante largo) para alimentar el driver antes del step-up, de IN+ a VM.","title":"Montaje el\u00e9ctrico"},{"location":"programacion/","text":"Programaci\u00f3n de Sapoconcho Ahora que ya tienes tu Sapoconcho montado.. \u00a1vamos a programarlo! Lo primero que necesitas es Arduino IDE , el programa que te permitir\u00e1 escribir el c\u00f3digo en el robot. Una vez instalado conecta el Arduino al ordenador usando el cable USB de tu kit y abre Arduino IDE. En el men\u00fa tools selecciona: Board: Arduino Uno Puerto: el puerto USB en el que tienes conectado el Arduino. Programando en Arduino Programar en Arduino es muy sencillo, tenemos dos funciones en las que escribir nuestro c\u00f3digo: Setup: el robot har\u00e1 lo que escribas aqu\u00ed cuando se encienda. Loop: el robot har\u00e1 esto continuamente una vez finalice el setup. void setup () { } void loop (){ } Truco Lo que escribas despu\u00e9s de una doble barra \"//\" no se ejecutar\u00e1, puedes usarlo para poner anotaciones en el c\u00f3digo. Funci\u00f3n de movimiento Para decirle al robot que se mueva vamos a usar una funci\u00f3n drive que os damos a continuaci\u00f3n (copia y p\u00e9gala al final de tu c\u00f3digo): // Drive permite manejar los motores // Izquierda y derecha admite valores de -100 a 100 // Tiempo en milisegundos void drive ( int izquierda , int derecha , int tiempo ) { //Arduino UNO y driver TB6612/DRV8833 const int AIN2 = 9 ; // PWMA const int AIN1 = 8 ; const int BIN1 = 7 ; const int BIN2 = 6 ; // PWMB pinMode ( AIN1 , OUTPUT ); pinMode ( AIN2 , OUTPUT ); pinMode ( BIN1 , OUTPUT ); pinMode ( BIN2 , OUTPUT ); izquierda = map ( constrain ( izquierda , -100 , 100 ), -100 , 100 , -255 , 255 ); derecha = map ( constrain ( derecha , -100 , 100 ), -100 , 100 , -255 , 255 ); digitalWrite ( AIN1 , izquierda < 0 ); analogWrite ( AIN2 , izquierda + 255 * ( izquierda < 0 )); digitalWrite ( BIN1 , derecha < 0 ); analogWrite ( BIN2 , derecha + 255 * ( derecha < 0 )); delay ( tiempo ); } Esta funci\u00f3n nos permite decirle al robot la velocidad de la rueda izquierda, rueda derecha y un tiempo. La velocidad de cada rueda admite valores de -100 a 100. El tiempo debemos indicarlo en milisegundos (1 segundo son 1000). Ahora debemos llamar a esta funci\u00f3n, para ello copia y pegar la siguiente linea dentro del loop de tu programa: drive ( 50 , 50 , 1000 ); Para enviar el c\u00f3digo al robot debes pulsar el bot\u00f3n upload . Ver\u00e1s una barra de progreso y en unos pocos segundos \u00a1tu robot habr\u00e1 recibido su primer c\u00f3digo! Ahora desconecta el cable USB del Sapoconcho, ponle la alimentaci\u00f3n de las pilas y comprueba que avanza hacia delante. \u00bfSapoconcho avanza en linea recta? Probablemente no.. esto se debe a que no existen dos motores exactamente iguales en el mundo y aunque les ordenemos ir a la misma velocidad no podr\u00e1n. Intenta ajustar los valores izquierda y derecha para que tu sapoconcho avance recto. Movimientos de prueba Habr\u00e1s notado que aunque le hemos puesto que avance un segundo Sapoconcho no para. Prueba a introducir una segunda instrucci\u00f3n a continuaci\u00f3n de la anterior para indicar a sapoconcho que pare: drive ( 0 , 0 , 1000 ); Si le env\u00edas este programa a Sapoconcho ahora ver\u00e1s que camina y para continuamente, \u00a1Esta es la m\u00e1gia de la funci\u00f3n loop ! \u00bfSe te ocurre como hacer que pare definitivamente? \u00a1Exacto! En lugar de poner el c\u00f3digo en el loop mu\u00e9velo al setup , de esta forma s\u00f3lo seguir\u00e1 tus instrucciones una vez. Ahora puedes probar a jugar con las distintas opciones que nos da la funci\u00f3n drive y encadenarlas para conseguir una secuencia de movimientos: Movimiento hacia adelante: izquierda y derecha con valores positivos. Movimiento hacia atr\u00e1s: izquierda y derecha con valores negativos. Giro en redondo: izquierda positivo, derecha negativo o viceversa. Giro en avance: valor de una rueda mayor que el de la otra. Parar: valores de izquierda y derecha en 0. \u00bfEres capaz de hacer un giro de 90 grados? Para hacerlo deber\u00e1s ajustar el tiempo que el robot est\u00e1 girando en redondo. Si lo consigues, intenta hacer un giro de 180 grados. Intenta que el robot dibuje la forma de un cuadrado. Deber\u00e1s concatenar avances y giros en redondo hacia un lado. Al estar en un bucle infinito solo necesitas dos instrucciones para conseguirlo. Si lo consigues, prueba con otras formas geom\u00e9tricas. \u00bfSaponconcho podr\u00e1 moverse como una serpiente? Concatenando varios giros en avance puedes conseguir que Sapoconcho se mueva en eses. Prueba a ponerle obst\u00e1culos e intenta evitarlos serpenteando. Sensores de ultrasonidos Los sensores del ultrasonidos permiten a Sapoconcho medir la distancia a los objetos que tiene delante. Sensor de ultrasonidos El sensor HC-SR04 tiene cuatro pines: alimentaci\u00f3n (VCC), trigger, echo y masa (GND), Trigger y echo los hemos unido con una soldadura para ahorrarnos un cable, aunque tenemos que advertir que es posible que modelos de algunos fabricantes no permitan esto, y al hacerlo no funcionen. Los sensores tienen casi siempre dos pines de alimentaci\u00f3n y uno o m\u00e1s pines de datos. La protoshield tiene en un lateral dos l\u00edneas para conectar la alimentaci\u00f3n a positivo (5V) y negativo (GND). Cablearemos con cables Dupont hembra-macho del sensor a la protoshield. VCC a uno de los conectores de 5V. GND a uno de los de masa. Trig o Echo al pin digital 2 del Arduino. El montaje del soporte a la placa superior es sencillo, con un tornillo M3x10 y una tuerca. La placa tiene tres orificios, usaremos el central para montar un \u00fanico sensor o los laterales para montar dos. Para leer la distancia que mide el sensor usaremos una nueva funci\u00f3n, que de nuevo copiaremos y pegaremos al final de nuestro programa. unsigned long sonar ( int pin ) { double calibracion = 0.017 ; // Calibraci\u00f3n del sensor pinMode ( pin , OUTPUT ); digitalWrite ( pin , LOW ); // Env\u00eda un pulso ultras\u00f3nico delayMicroseconds ( 5 ); digitalWrite ( pin , HIGH ); delayMicroseconds ( 10 ); pinMode ( pin , INPUT ); unsigned long tiempo = pulseIn ( pin , HIGH ); // Espera a recibir la respuesta unsigned long distancia = int ( calibracion * tiempo ); // Calcula la distancia return distancia ; } Para usarla debemos llamarla pas\u00e1ndole el pin al que hemos conectado el sensor, en este caso el 2. Esta funci\u00f3n nos devuelve un valor que guardaremos en una variable distancia . long int distancia = sonar ( 2 ); El siguiente c\u00f3digo permite leer el sensor y mostrar el resultado en el ordenador para poder comprobar que funciona y calibrarlo. Sapoconcho nos enviar\u00e1 los datos a trav\u00e9s del cable USB. C\u00f3digo void setup () { Serial . begin ( 9600 ); } void loop () { unsigned long distancia = sonar ( 2 ); // invocamos a funci\u00f3n de medir distancia Serial . print ( \"Distancia: \" ); // Enviamos los valores a la consola Serial . print ( distancia ); Serial . println ( \" cm\" ); } unsigned long sonar ( int pin ) { double calibracion = 0.017 ; // Calibraci\u00f3n del sensor pinMode ( pin , OUTPUT ); digitalWrite ( pin , LOW ); // Env\u00eda un pulso ultras\u00f3nico delayMicroseconds ( 5 ); digitalWrite ( pin , HIGH ); delayMicroseconds ( 10 ); pinMode ( pin , INPUT ); unsigned long tiempo = pulseIn ( pin , HIGH ); // Espera a recibir la respuesta unsigned long distancia = int ( calibracion * tiempo ); // Calcula la distancia return distancia ; } En el ordenador deberemos abrir el monitor serial que est\u00e1 en la barra superior en el margen derecho . Al igual que con los motores, cada sensor es diferente y tendremos que calibrar el nuestro para que mida correctamente los cent\u00edmetros. Puedes probar a ajustar la variable calibracion dentro de la funci\u00f3n sonar para que los valores que te muestra sean m\u00e1s realistas. Mantener la distancia Para utilizar el sensor combinado con el movimiento en Sapoconcho necesitaremos utilizar la instrucci\u00f3n if - else . En el siguiente programa comprobamos la distancia, si el obst\u00e1culo est\u00e1 lejos le decimos al robot que avance, si est\u00e1 cerca que retroceda. C\u00f3digo void setup () { } void loop () { long int distancia = sonar ( 2 ); if ( distancia < 10 ){ drive ( -75 , -75 , 50 ); } else { drive ( 75 , 75 , 50 ); } } void drive ( int izquierda , int derecha , int tiempo ) { //Arduino UNO y driver TB6612/DRV8833 const int AIN2 = 9 ; // PWMA const int AIN1 = 8 ; const int BIN1 = 7 ; const int BIN2 = 6 ; // PWMB pinMode ( AIN1 , OUTPUT ); pinMode ( AIN2 , OUTPUT ); pinMode ( BIN1 , OUTPUT ); pinMode ( BIN2 , OUTPUT ); izquierda = map ( constrain ( izquierda , -100 , 100 ), -100 , 100 , -255 , 255 ); derecha = map ( constrain ( derecha , -100 , 100 ), -100 , 100 , -255 , 255 ); digitalWrite ( AIN1 , izquierda < 0 ); analogWrite ( AIN2 , izquierda + 255 * ( izquierda < 0 )); digitalWrite ( BIN1 , derecha < 0 ); analogWrite ( BIN2 , derecha + 255 * ( derecha < 0 )); delay ( tiempo ); } unsigned long sonar ( int pin ) { double calibracion = 0.017 ; // Calibraci\u00f3n del sensor pinMode ( pin , OUTPUT ); digitalWrite ( pin , LOW ); // Env\u00eda un pulso ultras\u00f3nico delayMicroseconds ( 5 ); digitalWrite ( pin , HIGH ); delayMicroseconds ( 10 ); pinMode ( pin , INPUT ); unsigned long tiempo = pulseIn ( pin , HIGH ); // Espera a recibir la respuesta unsigned long distancia = int ( calibracion * tiempo ); // Calcula la distancia return distancia ; } Esto evitar\u00e1 que el robot choque con una pared hacia la que va de frente, adem\u00e1ssi en lugar de una pared ponemos la mano, conseguiremos manejar 'a distancia' nuestro robot. Como diversi\u00f3n si estamos trabajando en grupo podemos poner todos los robots en fila y encenderlos a la vez a ver qu\u00e9 pasa. Evitar obst\u00e1culos Si a nuestro robot le ponemos dos sensores de distancia podemos ver por donde est\u00e1 el obst\u00e1culo m\u00e1s cercano y girar hacia el lado contrario evit\u00e1ndolo. C\u00f3digo void setup () { } void loop () { long int izquierda = sonar ( 2 ); long int derecha = sonar ( 3 ); long int distancia = min ( izquierda , derecha ); if ( distancia < 10 ){ if ( izquierda < derecha ){ drive ( 75 , -75 , 100 ); } else { drive ( -75 , 75 , 100 ); } } else { drive ( 75 , 75 , 50 ); } } void drive ( int izquierda , int derecha , int tiempo ) { //Arduino UNO y driver TB6612/DRV8833 const int AIN2 = 9 ; // PWMA const int AIN1 = 8 ; const int BIN1 = 7 ; const int BIN2 = 6 ; // PWMB pinMode ( AIN1 , OUTPUT ); pinMode ( AIN2 , OUTPUT ); pinMode ( BIN1 , OUTPUT ); pinMode ( BIN2 , OUTPUT ); izquierda = map ( constrain ( izquierda , -100 , 100 ), -100 , 100 , -255 , 255 ); derecha = map ( constrain ( derecha , -100 , 100 ), -100 , 100 , -255 , 255 ); digitalWrite ( AIN1 , izquierda < 0 ); analogWrite ( AIN2 , izquierda + 255 * ( izquierda < 0 )); digitalWrite ( BIN1 , derecha < 0 ); analogWrite ( BIN2 , derecha + 255 * ( derecha < 0 )); delay ( tiempo ); } unsigned long sonar ( int pin ) { double calibracion = 0.017 ; // Calibraci\u00f3n del sensor pinMode ( pin , OUTPUT ); digitalWrite ( pin , LOW ); // Env\u00eda un pulso ultras\u00f3nico delayMicroseconds ( 5 ); digitalWrite ( pin , HIGH ); delayMicroseconds ( 10 ); pinMode ( pin , INPUT ); unsigned long tiempo = pulseIn ( pin , HIGH ); // Espera a recibir la respuesta unsigned long distancia = int ( calibracion * tiempo ); // Calcula la distancia return distancia ; } Esto tambi\u00e9n es posible hacerlo con un solo sensor, pero tendr\u00e1s que parar el robot y girarlo para medir en que direcci\u00f3n est\u00e1 el terreno m\u00e1s despejado \u00bfEres capaz de hacerlo? Sensores de l\u00edneas Los sensores infrarrojos de l\u00edneas, tanto con salida anal\u00f3gica como digital utilizan tres pines: alimentaci\u00f3n (VCC), masa (GND) y se\u00f1al. Debes revisar tu sensor, seg\u00fan el fabricante los sensores podr\u00edan estar en otro orden, no tiene por qu\u00e9 coincidir con la foto. Utilizaremos sensores basados en reflexi\u00f3n TCRT5000 con regulador (importante) que se montar\u00e1n en el chasis inferior y se cablean a 5v, GND y dos entradas anal\u00f3gicas entre A0 y A5 (con cables Dupont H-M de 20cm). Seguir una l\u00ednea Para leer los sensores no necesitamos una funci\u00f3n extra, Arduino puede hacerlo con su propia funci\u00f3n analogRead(pin). El siguiente c\u00f3digo lee los dos sensores y si uno de ellos est\u00e1 sobre la l\u00ednea negra gira hacia el otro lado para evitarla (necesita la funci\u00f3n drive). void setup () { } void loop () { if ( analogRead ( A0 ) < 500 ){ drive ( -75 , 75 , 100 ); } if ( analogRead ( A1 ) < 500 ) { drive ( 75 , -75 , 100 ); } drive ( 75 , 75 , 100 ); }","title":"Programaci\u00f3n"},{"location":"programacion/#programacion-de-sapoconcho","text":"Ahora que ya tienes tu Sapoconcho montado.. \u00a1vamos a programarlo! Lo primero que necesitas es Arduino IDE , el programa que te permitir\u00e1 escribir el c\u00f3digo en el robot. Una vez instalado conecta el Arduino al ordenador usando el cable USB de tu kit y abre Arduino IDE. En el men\u00fa tools selecciona: Board: Arduino Uno Puerto: el puerto USB en el que tienes conectado el Arduino.","title":"Programaci\u00f3n de Sapoconcho"},{"location":"programacion/#programando-en-arduino","text":"Programar en Arduino es muy sencillo, tenemos dos funciones en las que escribir nuestro c\u00f3digo: Setup: el robot har\u00e1 lo que escribas aqu\u00ed cuando se encienda. Loop: el robot har\u00e1 esto continuamente una vez finalice el setup. void setup () { } void loop (){ } Truco Lo que escribas despu\u00e9s de una doble barra \"//\" no se ejecutar\u00e1, puedes usarlo para poner anotaciones en el c\u00f3digo.","title":"Programando en Arduino"},{"location":"programacion/#funcion-de-movimiento","text":"Para decirle al robot que se mueva vamos a usar una funci\u00f3n drive que os damos a continuaci\u00f3n (copia y p\u00e9gala al final de tu c\u00f3digo): // Drive permite manejar los motores // Izquierda y derecha admite valores de -100 a 100 // Tiempo en milisegundos void drive ( int izquierda , int derecha , int tiempo ) { //Arduino UNO y driver TB6612/DRV8833 const int AIN2 = 9 ; // PWMA const int AIN1 = 8 ; const int BIN1 = 7 ; const int BIN2 = 6 ; // PWMB pinMode ( AIN1 , OUTPUT ); pinMode ( AIN2 , OUTPUT ); pinMode ( BIN1 , OUTPUT ); pinMode ( BIN2 , OUTPUT ); izquierda = map ( constrain ( izquierda , -100 , 100 ), -100 , 100 , -255 , 255 ); derecha = map ( constrain ( derecha , -100 , 100 ), -100 , 100 , -255 , 255 ); digitalWrite ( AIN1 , izquierda < 0 ); analogWrite ( AIN2 , izquierda + 255 * ( izquierda < 0 )); digitalWrite ( BIN1 , derecha < 0 ); analogWrite ( BIN2 , derecha + 255 * ( derecha < 0 )); delay ( tiempo ); } Esta funci\u00f3n nos permite decirle al robot la velocidad de la rueda izquierda, rueda derecha y un tiempo. La velocidad de cada rueda admite valores de -100 a 100. El tiempo debemos indicarlo en milisegundos (1 segundo son 1000). Ahora debemos llamar a esta funci\u00f3n, para ello copia y pegar la siguiente linea dentro del loop de tu programa: drive ( 50 , 50 , 1000 ); Para enviar el c\u00f3digo al robot debes pulsar el bot\u00f3n upload . Ver\u00e1s una barra de progreso y en unos pocos segundos \u00a1tu robot habr\u00e1 recibido su primer c\u00f3digo! Ahora desconecta el cable USB del Sapoconcho, ponle la alimentaci\u00f3n de las pilas y comprueba que avanza hacia delante. \u00bfSapoconcho avanza en linea recta? Probablemente no.. esto se debe a que no existen dos motores exactamente iguales en el mundo y aunque les ordenemos ir a la misma velocidad no podr\u00e1n. Intenta ajustar los valores izquierda y derecha para que tu sapoconcho avance recto. Movimientos de prueba Habr\u00e1s notado que aunque le hemos puesto que avance un segundo Sapoconcho no para. Prueba a introducir una segunda instrucci\u00f3n a continuaci\u00f3n de la anterior para indicar a sapoconcho que pare: drive ( 0 , 0 , 1000 ); Si le env\u00edas este programa a Sapoconcho ahora ver\u00e1s que camina y para continuamente, \u00a1Esta es la m\u00e1gia de la funci\u00f3n loop ! \u00bfSe te ocurre como hacer que pare definitivamente? \u00a1Exacto! En lugar de poner el c\u00f3digo en el loop mu\u00e9velo al setup , de esta forma s\u00f3lo seguir\u00e1 tus instrucciones una vez. Ahora puedes probar a jugar con las distintas opciones que nos da la funci\u00f3n drive y encadenarlas para conseguir una secuencia de movimientos: Movimiento hacia adelante: izquierda y derecha con valores positivos. Movimiento hacia atr\u00e1s: izquierda y derecha con valores negativos. Giro en redondo: izquierda positivo, derecha negativo o viceversa. Giro en avance: valor de una rueda mayor que el de la otra. Parar: valores de izquierda y derecha en 0. \u00bfEres capaz de hacer un giro de 90 grados? Para hacerlo deber\u00e1s ajustar el tiempo que el robot est\u00e1 girando en redondo. Si lo consigues, intenta hacer un giro de 180 grados. Intenta que el robot dibuje la forma de un cuadrado. Deber\u00e1s concatenar avances y giros en redondo hacia un lado. Al estar en un bucle infinito solo necesitas dos instrucciones para conseguirlo. Si lo consigues, prueba con otras formas geom\u00e9tricas. \u00bfSaponconcho podr\u00e1 moverse como una serpiente? Concatenando varios giros en avance puedes conseguir que Sapoconcho se mueva en eses. Prueba a ponerle obst\u00e1culos e intenta evitarlos serpenteando.","title":"Funci\u00f3n de movimiento"},{"location":"programacion/#sensores-de-ultrasonidos","text":"Los sensores del ultrasonidos permiten a Sapoconcho medir la distancia a los objetos que tiene delante. Sensor de ultrasonidos El sensor HC-SR04 tiene cuatro pines: alimentaci\u00f3n (VCC), trigger, echo y masa (GND), Trigger y echo los hemos unido con una soldadura para ahorrarnos un cable, aunque tenemos que advertir que es posible que modelos de algunos fabricantes no permitan esto, y al hacerlo no funcionen. Los sensores tienen casi siempre dos pines de alimentaci\u00f3n y uno o m\u00e1s pines de datos. La protoshield tiene en un lateral dos l\u00edneas para conectar la alimentaci\u00f3n a positivo (5V) y negativo (GND). Cablearemos con cables Dupont hembra-macho del sensor a la protoshield. VCC a uno de los conectores de 5V. GND a uno de los de masa. Trig o Echo al pin digital 2 del Arduino. El montaje del soporte a la placa superior es sencillo, con un tornillo M3x10 y una tuerca. La placa tiene tres orificios, usaremos el central para montar un \u00fanico sensor o los laterales para montar dos. Para leer la distancia que mide el sensor usaremos una nueva funci\u00f3n, que de nuevo copiaremos y pegaremos al final de nuestro programa. unsigned long sonar ( int pin ) { double calibracion = 0.017 ; // Calibraci\u00f3n del sensor pinMode ( pin , OUTPUT ); digitalWrite ( pin , LOW ); // Env\u00eda un pulso ultras\u00f3nico delayMicroseconds ( 5 ); digitalWrite ( pin , HIGH ); delayMicroseconds ( 10 ); pinMode ( pin , INPUT ); unsigned long tiempo = pulseIn ( pin , HIGH ); // Espera a recibir la respuesta unsigned long distancia = int ( calibracion * tiempo ); // Calcula la distancia return distancia ; } Para usarla debemos llamarla pas\u00e1ndole el pin al que hemos conectado el sensor, en este caso el 2. Esta funci\u00f3n nos devuelve un valor que guardaremos en una variable distancia . long int distancia = sonar ( 2 ); El siguiente c\u00f3digo permite leer el sensor y mostrar el resultado en el ordenador para poder comprobar que funciona y calibrarlo. Sapoconcho nos enviar\u00e1 los datos a trav\u00e9s del cable USB. C\u00f3digo void setup () { Serial . begin ( 9600 ); } void loop () { unsigned long distancia = sonar ( 2 ); // invocamos a funci\u00f3n de medir distancia Serial . print ( \"Distancia: \" ); // Enviamos los valores a la consola Serial . print ( distancia ); Serial . println ( \" cm\" ); } unsigned long sonar ( int pin ) { double calibracion = 0.017 ; // Calibraci\u00f3n del sensor pinMode ( pin , OUTPUT ); digitalWrite ( pin , LOW ); // Env\u00eda un pulso ultras\u00f3nico delayMicroseconds ( 5 ); digitalWrite ( pin , HIGH ); delayMicroseconds ( 10 ); pinMode ( pin , INPUT ); unsigned long tiempo = pulseIn ( pin , HIGH ); // Espera a recibir la respuesta unsigned long distancia = int ( calibracion * tiempo ); // Calcula la distancia return distancia ; } En el ordenador deberemos abrir el monitor serial que est\u00e1 en la barra superior en el margen derecho . Al igual que con los motores, cada sensor es diferente y tendremos que calibrar el nuestro para que mida correctamente los cent\u00edmetros. Puedes probar a ajustar la variable calibracion dentro de la funci\u00f3n sonar para que los valores que te muestra sean m\u00e1s realistas. Mantener la distancia Para utilizar el sensor combinado con el movimiento en Sapoconcho necesitaremos utilizar la instrucci\u00f3n if - else . En el siguiente programa comprobamos la distancia, si el obst\u00e1culo est\u00e1 lejos le decimos al robot que avance, si est\u00e1 cerca que retroceda. C\u00f3digo void setup () { } void loop () { long int distancia = sonar ( 2 ); if ( distancia < 10 ){ drive ( -75 , -75 , 50 ); } else { drive ( 75 , 75 , 50 ); } } void drive ( int izquierda , int derecha , int tiempo ) { //Arduino UNO y driver TB6612/DRV8833 const int AIN2 = 9 ; // PWMA const int AIN1 = 8 ; const int BIN1 = 7 ; const int BIN2 = 6 ; // PWMB pinMode ( AIN1 , OUTPUT ); pinMode ( AIN2 , OUTPUT ); pinMode ( BIN1 , OUTPUT ); pinMode ( BIN2 , OUTPUT ); izquierda = map ( constrain ( izquierda , -100 , 100 ), -100 , 100 , -255 , 255 ); derecha = map ( constrain ( derecha , -100 , 100 ), -100 , 100 , -255 , 255 ); digitalWrite ( AIN1 , izquierda < 0 ); analogWrite ( AIN2 , izquierda + 255 * ( izquierda < 0 )); digitalWrite ( BIN1 , derecha < 0 ); analogWrite ( BIN2 , derecha + 255 * ( derecha < 0 )); delay ( tiempo ); } unsigned long sonar ( int pin ) { double calibracion = 0.017 ; // Calibraci\u00f3n del sensor pinMode ( pin , OUTPUT ); digitalWrite ( pin , LOW ); // Env\u00eda un pulso ultras\u00f3nico delayMicroseconds ( 5 ); digitalWrite ( pin , HIGH ); delayMicroseconds ( 10 ); pinMode ( pin , INPUT ); unsigned long tiempo = pulseIn ( pin , HIGH ); // Espera a recibir la respuesta unsigned long distancia = int ( calibracion * tiempo ); // Calcula la distancia return distancia ; } Esto evitar\u00e1 que el robot choque con una pared hacia la que va de frente, adem\u00e1ssi en lugar de una pared ponemos la mano, conseguiremos manejar 'a distancia' nuestro robot. Como diversi\u00f3n si estamos trabajando en grupo podemos poner todos los robots en fila y encenderlos a la vez a ver qu\u00e9 pasa. Evitar obst\u00e1culos Si a nuestro robot le ponemos dos sensores de distancia podemos ver por donde est\u00e1 el obst\u00e1culo m\u00e1s cercano y girar hacia el lado contrario evit\u00e1ndolo. C\u00f3digo void setup () { } void loop () { long int izquierda = sonar ( 2 ); long int derecha = sonar ( 3 ); long int distancia = min ( izquierda , derecha ); if ( distancia < 10 ){ if ( izquierda < derecha ){ drive ( 75 , -75 , 100 ); } else { drive ( -75 , 75 , 100 ); } } else { drive ( 75 , 75 , 50 ); } } void drive ( int izquierda , int derecha , int tiempo ) { //Arduino UNO y driver TB6612/DRV8833 const int AIN2 = 9 ; // PWMA const int AIN1 = 8 ; const int BIN1 = 7 ; const int BIN2 = 6 ; // PWMB pinMode ( AIN1 , OUTPUT ); pinMode ( AIN2 , OUTPUT ); pinMode ( BIN1 , OUTPUT ); pinMode ( BIN2 , OUTPUT ); izquierda = map ( constrain ( izquierda , -100 , 100 ), -100 , 100 , -255 , 255 ); derecha = map ( constrain ( derecha , -100 , 100 ), -100 , 100 , -255 , 255 ); digitalWrite ( AIN1 , izquierda < 0 ); analogWrite ( AIN2 , izquierda + 255 * ( izquierda < 0 )); digitalWrite ( BIN1 , derecha < 0 ); analogWrite ( BIN2 , derecha + 255 * ( derecha < 0 )); delay ( tiempo ); } unsigned long sonar ( int pin ) { double calibracion = 0.017 ; // Calibraci\u00f3n del sensor pinMode ( pin , OUTPUT ); digitalWrite ( pin , LOW ); // Env\u00eda un pulso ultras\u00f3nico delayMicroseconds ( 5 ); digitalWrite ( pin , HIGH ); delayMicroseconds ( 10 ); pinMode ( pin , INPUT ); unsigned long tiempo = pulseIn ( pin , HIGH ); // Espera a recibir la respuesta unsigned long distancia = int ( calibracion * tiempo ); // Calcula la distancia return distancia ; } Esto tambi\u00e9n es posible hacerlo con un solo sensor, pero tendr\u00e1s que parar el robot y girarlo para medir en que direcci\u00f3n est\u00e1 el terreno m\u00e1s despejado \u00bfEres capaz de hacerlo?","title":"Sensores de ultrasonidos"},{"location":"programacion/#sensores-de-lineas","text":"Los sensores infrarrojos de l\u00edneas, tanto con salida anal\u00f3gica como digital utilizan tres pines: alimentaci\u00f3n (VCC), masa (GND) y se\u00f1al. Debes revisar tu sensor, seg\u00fan el fabricante los sensores podr\u00edan estar en otro orden, no tiene por qu\u00e9 coincidir con la foto. Utilizaremos sensores basados en reflexi\u00f3n TCRT5000 con regulador (importante) que se montar\u00e1n en el chasis inferior y se cablean a 5v, GND y dos entradas anal\u00f3gicas entre A0 y A5 (con cables Dupont H-M de 20cm). Seguir una l\u00ednea Para leer los sensores no necesitamos una funci\u00f3n extra, Arduino puede hacerlo con su propia funci\u00f3n analogRead(pin). El siguiente c\u00f3digo lee los dos sensores y si uno de ellos est\u00e1 sobre la l\u00ednea negra gira hacia el otro lado para evitarla (necesita la funci\u00f3n drive). void setup () { } void loop () { if ( analogRead ( A0 ) < 500 ){ drive ( -75 , 75 , 100 ); } if ( analogRead ( A1 ) < 500 ) { drive ( 75 , -75 , 100 ); } drive ( 75 , 75 , 100 ); }","title":"Sensores de l\u00edneas"},{"location":"taller/","text":"Preparar un taller de Sapoconcho Sapoconcho fue concebido principalmente para impartir talleres de rob\u00f3tica. El p\u00fablico principal para el que est\u00e1 pensado es para ni\u00f1os de entre 11 y 18 a\u00f1os o formadores que posteriormente utilizar\u00e1n Sapoconcho en sus clases. Es muy habitual y recomendable que si los ni\u00f1os son peque\u00f1os (11-14 a\u00f1os) hagan el taller acompa\u00f1ados por un adulto. Duraci\u00f3n del taller Bas\u00e1ndonos en experiencias anteriores podemos indicar las siguientes duraciones: Montaje: 60 minutos Programaci\u00f3n movimiento: 45 minutos Programaci\u00f3n ultrasonidos: 45 minutos Programaci\u00f3n siguelineas: 45 minutos Es posible alargar el taller o dividirlo en dos sesiones si se incluye la parte de preparado de los kits. Para esta parte la edad recomendada deber\u00eda ser un poco mayor ya que requiere soldar con esta\u00f1ador. Preparativos previos Preparando los kits Las siguientes indicaciones pueden ahorrarnos problemas durante el taller: Preparar al menos un 1 kit extra por cada 10 por si faltan o fallan piezas en alguno. Revisar los di\u00e1metros de los agujeros en las piezas impresas, especialmente los del eje de los motores que deben entrar justos. Soldar los pines del driver de motores. Cortar y pelar los cables para breadboard a medida. Soldar cables al step-up y al conector de alimentaci\u00f3n. Regular el voltaje del step-up. Soldar los dos pines centrales del sensor de ultrasonidos. Preparativos de los participantes Es recomendable que los participantes traigan Arduino IDE instalado en sus port\u00e1tiles de forma que evitemos problemas con la descarga o instalaci\u00f3n durante el taller. Durante el taller Es recomendable tener a mano los siguientes materiales y herramientas por si fuesen necesarias: Estaci\u00f3n de soldadura (esta\u00f1ador, esta\u00f1o y dem\u00e1s \u00fatiles) Destornillador el\u00e9ctrico con punta hexagonal Cable para breadboard Alicates de corte Pelacables Mult\u00edmetro Lima y broca de 3mm (por si los di\u00e1metros del eje de las ruedas fuesen peque\u00f1os) Loctite (por si los di\u00e1metros del eje de las ruedas son demasiado holgados) Cinta de doble cara Bridas Instalador de Arduino IDE en un pen-drive","title":"Taller"},{"location":"taller/#preparar-un-taller-de-sapoconcho","text":"Sapoconcho fue concebido principalmente para impartir talleres de rob\u00f3tica. El p\u00fablico principal para el que est\u00e1 pensado es para ni\u00f1os de entre 11 y 18 a\u00f1os o formadores que posteriormente utilizar\u00e1n Sapoconcho en sus clases. Es muy habitual y recomendable que si los ni\u00f1os son peque\u00f1os (11-14 a\u00f1os) hagan el taller acompa\u00f1ados por un adulto.","title":"Preparar un taller de Sapoconcho"},{"location":"taller/#duracion-del-taller","text":"Bas\u00e1ndonos en experiencias anteriores podemos indicar las siguientes duraciones: Montaje: 60 minutos Programaci\u00f3n movimiento: 45 minutos Programaci\u00f3n ultrasonidos: 45 minutos Programaci\u00f3n siguelineas: 45 minutos Es posible alargar el taller o dividirlo en dos sesiones si se incluye la parte de preparado de los kits. Para esta parte la edad recomendada deber\u00eda ser un poco mayor ya que requiere soldar con esta\u00f1ador.","title":"Duraci\u00f3n del taller"},{"location":"taller/#preparativos-previos","text":"","title":"Preparativos previos"},{"location":"taller/#preparando-los-kits","text":"Las siguientes indicaciones pueden ahorrarnos problemas durante el taller: Preparar al menos un 1 kit extra por cada 10 por si faltan o fallan piezas en alguno. Revisar los di\u00e1metros de los agujeros en las piezas impresas, especialmente los del eje de los motores que deben entrar justos. Soldar los pines del driver de motores. Cortar y pelar los cables para breadboard a medida. Soldar cables al step-up y al conector de alimentaci\u00f3n. Regular el voltaje del step-up. Soldar los dos pines centrales del sensor de ultrasonidos.","title":"Preparando los kits"},{"location":"taller/#preparativos-de-los-participantes","text":"Es recomendable que los participantes traigan Arduino IDE instalado en sus port\u00e1tiles de forma que evitemos problemas con la descarga o instalaci\u00f3n durante el taller.","title":"Preparativos de los participantes"},{"location":"taller/#durante-el-taller","text":"Es recomendable tener a mano los siguientes materiales y herramientas por si fuesen necesarias: Estaci\u00f3n de soldadura (esta\u00f1ador, esta\u00f1o y dem\u00e1s \u00fatiles) Destornillador el\u00e9ctrico con punta hexagonal Cable para breadboard Alicates de corte Pelacables Mult\u00edmetro Lima y broca de 3mm (por si los di\u00e1metros del eje de las ruedas fuesen peque\u00f1os) Loctite (por si los di\u00e1metros del eje de las ruedas son demasiado holgados) Cinta de doble cara Bridas Instalador de Arduino IDE en un pen-drive","title":"Durante el taller"}]}